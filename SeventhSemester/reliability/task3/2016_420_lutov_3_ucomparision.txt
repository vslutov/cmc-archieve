# Результаты

## Без механизмов обеспечения надежности

A[] not deadlock - yes
E<> ready[1] && ready[2] && ready[3] && ready[4] && ready[5] && ready[6] && ready[7] && ready[8] && ready[9] && delay < 15 - yes
E<> ready[1] && ready[2] && ready[3] && ready[4] && ready[5] && ready[6] && ready[7] && ready[8] && ready[9] && delay < 14 - no

## С механизмами обеспечения надежности

A[] not deadlock - yes
E<> ready[1] && ready[2] && ready[3] && ready[4] && ready[5] && ready[6] && ready[7] && ready[8] && ready[9] && delay < 20 - yes
E<> ready[1] && ready[2] && ready[3] && ready[4] && ready[5] && ready[6] && ready[7] && ready[8] && ready[9] && delay < 19 - no

# Минимальное время задержки

Без механизмов резервирования: 14 тактов.
С механизмами: 19 тактов.

Оптимальное расписание можно увидеть в GUI Uppaal.

# Комментарии по uppaal

В данной задаче время работы uppaal не зависит от способа обхода дерева.
К сожалению, в системе uppaal невозможно работать с переменными типа clock как
с целыми числами - вычитать, складывать и присваивать их. Поэтому для реализации
счетчика суммарного простоя приходится реализовать его руками и время работы
занимает очень много.
